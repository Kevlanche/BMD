package com.kevlanche.beaversmustdie;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;

public class Shark extends Actor {

	Vector2 speed;
	boolean inWater;
	float waterTime;
	SharkSweetAirJumpTimeReportReceiver listener;
	
	public interface SharkSweetAirJumpTimeReportReceiver {
		public void onSharkDidSweetJumpFor(float duration);
		public void sharkIsDoingSweetJumpFor(float duration);
	}
	
	public Shark(SharkSweetAirJumpTimeReportReceiver listener) {
		setSize(Mane.PTM_RATIO, Mane.PTM_RATIO);
		setOrigin(getWidth()/2, getHeight()/2);
		speed = new Vector2();
		inWater = true;
		this.listener = listener;
	}
	@Override
	public void act(float delta) {
		super.act(delta);
		
		waterTime += delta;
		
		float distFromCenter = (float)Math.hypot(getX()+getWidth()/2, getY()+getHeight()/2) / Mane.PTM_RATIO;
		
		float mvx = 0.0f;
		float mvy = -MathUtils.clamp(distFromCenter/Water.WATER_RADIUS, 0.5f, 1.5f); //gravity, bitch!
		
		if (Gdx.input.isKeyPressed(Keys.A))
			mvx--;
		if (Gdx.input.isKeyPressed(Keys.D))
			mvx++;
		
		if (distFromCenter < Water.WATER_RADIUS) { //only y-axis control in water
			
			if (!inWater) {
				inWater = true;
				listener.onSharkDidSweetJumpFor(waterTime);
			}
			if (Gdx.input.isKeyPressed(Keys.S))
				mvy-=2;
			if (Gdx.input.isKeyPressed(Keys.W))
				mvy+=2;
			
		} else {
			
			if (inWater) {
				inWater = false;
				waterTime = 0.0f;
			}
			mvy *= 2;
		}
		
		
		Vector2 trans = new Vector2(mvx, mvy);
		trans.nor().scl(.25f * Mane.PTM_RATIO * delta);
		
		speed.scl(0.99f);
		
		speed.x += trans.x;
		speed.y += trans.y;
		
		if (speed.len() > 10.0f)
			speed.nor().scl(10.0f);
		
		trans.set(speed);
		trans.rotate(getRotation());
		
		translate(trans.x, trans.y);
		
		distFromCenter = (float)Math.hypot(getX()+getWidth()/2, getY()+getHeight()/2) / Mane.PTM_RATIO;
		
		if (distFromCenter < Water.EARTH_RADIUS) { //move out of the earth's core, dummy!
			trans.set(0.0f, Mane.PTM_RATIO * (Water.EARTH_RADIUS-distFromCenter));
			trans.rotate(getRotation());
			translate(trans.x, trans.y);
			speed.y = Math.max(0.0f, speed.y);
		}
		
		float ang = MathUtils.atan2(getY()+getHeight()/2, getX()+getWidth()/2)+ MathUtils.PI;
		setRotation(MathUtils.radiansToDegrees * ang + 90.0f);
	
		
	}

	@Override
	public void draw(SpriteBatch batch, float parentAlpha) {
		batch.draw(Assets.smiley, getX(), getY(), getOriginX(), getOriginY(), getWidth(), getHeight(), getScaleX(), getScaleY(), getRotation());
	}
	
}
